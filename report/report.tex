\documentclass[11pt, a4paper, twoside, openright]{article} 

\usepackage{graphicx,color}
\usepackage{amssymb, amsmath, array, cite, float, url}



\begin{document}

\input{cover}

\newpage
\setcounter{page}{1}
\tableofcontents
\newpage
        

\section{Introduction}
The goal of the project is to implement a smart contract execution environment which uses WebAssembly \cite{webassembly} to handle smart contracts written in different languages. It must communicate with the DELA framework \cite{dela}, which is a blockchain-based distributed ledger currently developed in Go by the Decentralized and Distributed Systems lab.
Only a small subset of said framework must receive changes to communicate with the new environment. As a result, the vast majority of the work is focused on the environment itself, which is implemented from scratch.

\subsection{Motivation}

\begin{figure}[htbp]
 \centering
  \includegraphics[width=12cm]{wasm1.png}
  \caption{Native smart contracts execution environment.}
\end{figure}


As shown in figure 1, the standard way of executing a smart contract in DELA is inside of a node's environment, which we call ``native'' execution. While this method is very intuitive and efficient, it has two main limitations. The first one is that adding, removing or modifying a smart contract requires re-compiling the entirety of the environment, which is highly unpractical in a realistic blockchain scenario where such changes are frequent. The second is that smart contracts are required to be pre-compiled for the environment running the ledger and must thus be written in the same language, which is Go in this case.

\begin{figure}[htbp]
 \centering
  \includegraphics[width=12cm]{wasm2.png}
  \caption{Decoupled smart contracts execution environment.}
\end{figure}

To circumvent the first limitation, the obvious solution is to decouple the smart contract execution environment from the node's environment, as illustrated in figure 2. Any modification on the smart contracts would only require recompiling the smaller, decoupled environment which opens up the possibility of loading and unloading smart contracts dynamically without interrupting the main DELA environment. With this decoupled environment, smart contracts must not necessarily be written in Go, which somewhat takes care of the second limitation. However, supporting multiple languages efficiently is not straightforward and requires something else, which is when WebAssembly comes into the picture.

WebAssembly (WASM) is an open standard that defines a binary format which can obtained from higher level compatible languages, which we call ``source languages'' in this report. As its name implies, it is made up of low level ``Assembly-like'' instructions which can thus be run on a wide range of machines very efficiently. The WASM code is executed in a sandboxed environment. This added flexibility, its host independence and low performance penalty make it an ideal candidate for a smart-contract runtime used by many nodes trying to reach a consensus. Ethereum's proposed redesign of their execution layer using WASM further indicates that there is great potential for the technology in the blockchain field. 

\subsection{Goals}
\label{Goals}

\begin{enumerate} 

\itemsep0em

 \item Implementation of a fully functional execution module that uses WASM
 \item Simultaneous support of multiple smart contracts written in different languages
 \item Justification of configuration choices and the selection of compatible languages
 \item Performance comparisons
 \item Determinism analysis
 \item Testing comparable to the native module

\end{enumerate} 
\newpage

\section{Design}

\subsection{General Configuration}
The most important design decision during the project was selecting the ``kind'' of environment that should be implemented. WebAssembly was introduced in 2017 and its initial aim was to enable high performance web-browser applications with the help of a JavaScript API. Over time however, WASM started seeing use outside of browsers because of its many advantages, especially its near-native performance and consistent execution across different hardwares. As a result, three options were identified and considered : a web browser application, a web server and a unix daemon.

The first factor that was taken into account was the general lack of resources on WASM, which is severely exacerbated when the environment is not browser-based. Additionally, when dealing both with a non-browser solution as well as unusual source languages like Go, information about the specific interactions become virtually nonexistent. The daemon would have communicated with the DELA framework using unix sockets and would have used a runtime like Wasmer \cite{wasmer}, Wasmtime \cite{wasmtime} or WAVM \cite{wavm}, but was quickly deemed to be the riskiest option. Not only was it the least documented kind of environment and the most different from the standard browser solution, it was also identified that those non-web environments were transitioning to the Web Assembly Interface (WASI) \cite{wasi}.

As a response to the aforementioned attempts to use WASM outside of web-browsers, WASI was introduced in 2019 to achieve standardisation and extend WASM to the OS level. The fact that it was newer and less mature than ``standard WASM'' further increased risks. Additionally, many languages such as Go do not yet support compilation into WASM binaries which are compatible with this interface. The transition also meant that almost all up-to-date information about non-web solutions were about using WASI.

The aforementioned points about the lack of resources and WASI not only apply to a unix daemon solution but also to a Node.js server-based solution communicating over HTTP, though less severely. While Node.js does expect its users to use its WASI API, it supports a limited portion of the standard WASM JavaScript API. However, there was no evidence that Node.js could handle Go's unusual WASM implementation (which is further discussed in Part 2.2) and early tries to make it work failed.

Even though a web-browser application functionally makes less sense than the other options since the DELA framework would interact with it and not a human using a browser, it was thus the chosen solution during the early stages of the project and a working implementation was possible thanks to sufficient resources. However, its communication with DELA was initially simplified and it was identified that it would become very problematic as the environment would grow in complexity, since such a browser-based solution cannot easily and efficiently communicate with the framework. This prompted a second round of tries to make a Node.js solution work despite the limitations and the lack of information on unusual interactions.

Luckily, this second round was successful which was the best case scenario : a working Node.js solution which uses the Javascript "standard WASM" API and not the Node.js WASI API provides the best of both worlds for the project. Intentionally ignoring the WASI API limits risks as it is still experimental and enables the handling of smart contracts written in a wider range of languages. At the same time, using an HTTP server instead of a browser application provides an undeniably superior communication with the DELA framework. While the interaction with WASM binaries is not done with the intended Node.js API, this is the superior configuration for the project's specific needs at the present time ; there are currently no concrete time estimates on WASI support for multiple languages and on a stable release of the Node.js WASI API.


\subsection{Supported Languages}

Similarly to the freedom on the general configuration of the environment, the choice of which smart contract languages to support was free and part of the project.

Language compatibilities that were guaranteed to be worth prioritising are C and C++, since they were the two intended source languages when WebAssembly was introduced, before other languages added WASM compatibility as well. The target binaries are obtained from both languages with Emscripten \cite{emscripten}, a compiler toolchain which uses LLVM \cite{llvm}. The quality of the source language to WASM translation with Emscripten and the performance of the resulting binaries are considered to be state of the art in the world of WASM compatible languages, which made the environment support of the two languages even more indispensable since we are interested in comparing performance with native executions of smart contracts. Another obvious advantage is their extreme prevalence and that their simultaneous support incurs negligible additional work.

The other language which is supported is Go, which was chosen for many reasons. The first is that comparisons between the native and WASM executions can become more interesting when the exact same smart contract is compared in both cases, which is only possible if the native language is supported by the WASM environment. This can provide a precise comparison on the performance penalty caused by WASM and the communication with DELA, since external differences caused by differences in languages are removed. Another advantage is that Go is frequently used by the DEDIS lab, which means that its support could be very convenient in the future.

Something that was not known when choosing Go was a fundamental difference compared to other languages : C and C++ for example treat WASM as a library, while Go treats it as an application. This results in profound differences that requires the binaries to be treated very differently depending on the source language, even after the WASM compilation has been done. This caused many additional difficulties which are discussed in part 3 and a lot of the work done to support Go could not be reused to support C/C++. Even though this had a negative impact on productivity, this makes the addition of Go way more interesting than another language whose WASM support is similar to C/C++ and allows interesting performance comparisons between what is considered the state of the art WASM support and a more subpar one in the case of Go. Since the project also mostly acts as an exploratory experiment and not a final, ready to launch product, it is also good to prove that this kind of solution can handle less common languages with poorer WASM support.

Another language which was a strong candidate is Rust, which is considered to have the second best WASM support after C/C++ and whose binaries are similarly obtained from Emscripten. However, it it not currently supported by the environment because other goals were judged more important than adding another language whose support is similar to two supported languages when the ability of the environment to handle different languages simultaneously was already demonstrated. However, its inclusion could be a worthy time investment in the future and should be straightforward considering the similarity of the process to the C/C++ inclusion.


\section{Implementation}

\subsection{WebAssembly Compilation}

\subsection{Environment Setup}

\subsection{Smart Contract Execution}

\subsection{Communication with DELA}


\section{Results}

\subsection{Counter Increase}

\subsection{Generator Multiplication}

\subsection{ed25519 Point Addition}

\subsection{ed25519 Point Multiplication}

\section{Discussion}

\subsection{Determinism}

\subsection{Automated Smart Contract Loading}


\section{Future Work}

\section{Conclusion}
\newpage
\section{Bibliography}
\bibliographystyle{unsrt}
\bibliography{biblio}
\end{document}
